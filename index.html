<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>研究者ネットワークグラフ</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    h1, h2 {
      color: #333;
      margin-top: 0;
    }
    .main-content {
      display: flex;
      flex-direction: row;
      gap: 20px;
    }
    .graph-area {
      flex: 3;
      order: 1;
    }
    .controls-area {
      flex: 1;
      order: 2;
      min-width: 250px;
    }
    .control-group {
      border: 1px solid #ddd;
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 15px;
    }
    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
    }
    input, select {
      width: 100%;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-sizing: border-box;
    }
    .community-container {
      margin-top: 20px;
    }
    .community-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
    }
    .community-button {
      background-color: #f0f0f0;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 5px 10px;
      cursor: pointer;
      margin-bottom: 5px;
    }
    .community-button.active {
      background-color: #3498db;
      color: white;
      border-color: #2980b9;
    }
    .graph-container {
      border: 1px solid #ddd;
      border-radius: 5px;
      overflow: hidden;
      background-color: white;
      height: 700px;
    }
    svg {
      display: block;
      width: 100%;
      height: 100%;
    }
    .loading {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100%;
      font-size: 18px;
      color: #666;
    }
    .error {
      background-color: #ffebee;
      color: #c62828;
      padding: 15px;
      border-radius: 5px;
      border: 1px solid #ef9a9a;
      margin-bottom: 20px;
    }
    .notes {
      margin-top: 20px;
      font-size: 14px;
      color: #666;
    }
    .notes h3 {
      font-size: 16px;
      color: #333;
      margin-top: 10px;
    }
    .notes ul {
      padding-left: 20px;
      margin-top: 5px;
    }
    @media (max-width: 768px) {
      .main-content {
        flex-direction: column;
      }
      .graph-area {
        order: 2;
      }
      .controls-area {
        order: 1;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>研究者ネットワークグラフ</h1>
    
    <div id="error-message" class="error" style="display: none;"></div>
    
    <div class="main-content">
      <!-- グラフエリア (左側・メイン) -->
      <div class="graph-area">
        <div class="graph-container">
          <div id="loading" class="loading">データを読み込み中...</div>
          <svg id="graph" style="display: none;"></svg>
        </div>
      </div>
      
      <!-- コントロールエリア (右側) -->
      <div class="controls-area">
        <div class="control-group">
          <label for="min-paper-count">論文数フィルタ（最小値）</label>
          <input type="number" id="min-paper-count" min="1" max="20" value="1">
        </div>
        
        <div class="control-group">
          <label for="max-nodes">表示ノード数（上位）</label>
          <input type="number" id="max-nodes" min="10" max="50000" value="10000">
        </div>
        
        <div class="control-group">
          <label for="centrality-measure">中心性指標の選択</label>
          <select id="centrality-measure">
            <option value="pagerank">PageRank</option>
            <option value="degree_centrality">次数中心性</option>
            <option value="betweenness_centrality">媒介中心性</option>
            <option value="closeness_centrality">近接中心性</option>
            <option value="papers_count">論文数</option>
          </select>
        </div>
        
        <div class="notes">
          <h3>注釈:</h3>
          <ul>
            <li>ノードのサイズは選択された中心性指標に比例</li>
            <li>ノードの色はコミュニティを表す</li>
            <li>マウスホバーで詳細情報を表示</li>
            <li>ノードはドラッグして移動可能</li>
            <li>ホイールでズームイン・ズームアウト可能</li>
          </ul>
        </div>
      </div>
    </div>
    
    <!-- コミュニティフィルタエリア (最下部) -->
    <div class="community-container">
      <div class="control-group">
        <label>コミュニティフィルタ</label>
        <div id="community-buttons" class="community-buttons">
          <button class="community-button active" data-community="all">すべて</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // グローバル変数
    let nodeData = [];
    let linkData = [];
    let communities = [];
    let simulation;
    
    // DOM要素
    const svg = d3.select('#graph');
    const loadingElement = document.getElementById('loading');
    const errorElement = document.getElementById('error-message');
    const minPaperCountInput = document.getElementById('min-paper-count');
    const maxNodesInput = document.getElementById('max-nodes');
    const centralityMeasureSelect = document.getElementById('centrality-measure');
    const communityButtonsContainer = document.getElementById('community-buttons');
    
    // 現在の設定値
    let settings = {
      minPaperCount: 1,
      maxNodesToShow: 10000,
      centralityMeasure: 'pagerank',
      communityFilter: null
    };
    
    // データの読み込み
    async function fetchData() {
      try {
        showLoading(true);
        showError(null);
        
        const response = await fetch('enhanced_anlp_author_network.json');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        // ノードデータを設定
        nodeData = data.nodes || [];
        
        // リンクデータを設定（JSONに含まれている場合）
        if (data.links) {
          linkData = data.links;
        } else {
          // リンクデータがない場合、共著関係から生成
          linkData = generateLinksFromCoauthorship(nodeData);
        }
        
        // コミュニティ一覧を抽出
        if (nodeData.length > 0) {
          communities = [...new Set(nodeData.map(node => node.community))].sort((a, b) => a - b);
          populateCommunityButtons(communities);
        }
        
        createNetworkGraph();
        showLoading(false);
      } catch (error) {
        console.error('Error loading data:', error);
        showError('データの読み込みに失敗しました: ' + error.message);
        showLoading(false);
      }
    }
    
    // 共著関係からリンクを生成するヘルパー関数
    function generateLinksFromCoauthorship(nodes) {
      const links = [];
      const paperAuthors = {};
      
      // 各論文の著者リストを作成
      nodes.forEach(node => {
        if (node.papers) {
          node.papers.forEach(paperId => {
            if (!paperAuthors[paperId]) {
              paperAuthors[paperId] = [];
            }
            paperAuthors[paperId].push(node.id);
          });
        }
      });
      
      // 共著関係からリンクを生成
      Object.values(paperAuthors).forEach(authors => {
        if (authors.length > 1) {
          for (let i = 0; i < authors.length; i++) {
            for (let j = i + 1; j < authors.length; j++) {
              // 既存のリンクを見つける
              const existingLink = links.find(
                link => 
                  (link.source === authors[i] && link.target === authors[j]) ||
                  (link.source === authors[j] && link.target === authors[i])
              );
              
              if (existingLink) {
                // 既存のリンクの重みを増加
                existingLink.value = (existingLink.value || 1) + 1;
              } else {
                // 新しいリンクを追加
                links.push({
                  source: authors[i],
                  target: authors[j],
                  value: 1
                });
              }
            }
          }
        }
      });
      
      return links;
    }
    
    // コミュニティボタンを生成
    function populateCommunityButtons(communities) {
      // 既存のボタンをクリア（「すべて」ボタンを除く）
      const allButton = communityButtonsContainer.querySelector('[data-community="all"]');
      communityButtonsContainer.innerHTML = '';
      communityButtonsContainer.appendChild(allButton);
      
      // コミュニティごとにボタンを追加
      communities.forEach(community => {
        const button = document.createElement('button');
        button.className = 'community-button';
        button.setAttribute('data-community', community);
        button.textContent = `コミュニティ ${community}`;
        button.addEventListener('click', () => {
          // アクティブなボタンを更新
          document.querySelectorAll('.community-button').forEach(btn => {
            btn.classList.remove('active');
          });
          button.classList.add('active');
          
          // コミュニティフィルタを設定して再描画
          settings.communityFilter = community;
          createNetworkGraph();
        });
        communityButtonsContainer.appendChild(button);
      });
      
      // 「すべて」ボタンのイベントリスナーを追加
      allButton.addEventListener('click', () => {
        // アクティブなボタンを更新
        document.querySelectorAll('.community-button').forEach(btn => {
          btn.classList.remove('active');
        });
        allButton.classList.add('active');
        
        // コミュニティフィルタをクリアして再描画
        settings.communityFilter = null;
        createNetworkGraph();
      });
    }
    
    // グラフの作成
    function createNetworkGraph() {
      if (nodeData.length === 0) return;
      
      // SVGをクリア
      svg.selectAll("*").remove();
      
      // ノードをフィルタリング
      let filteredNodes = nodeData.filter(node => node.papers_count >= settings.minPaperCount);
      
      // コミュニティでフィルタリング
      if (settings.communityFilter !== null) {
        filteredNodes = filteredNodes.filter(node => node.community === settings.communityFilter);
      }
      
      // 中心性指標でソートして上位を取得
      filteredNodes = _.orderBy(filteredNodes, [settings.centralityMeasure], ['desc'])
        .slice(0, settings.maxNodesToShow);
      
      // フィルタリングされたノードのIDを取得
      const nodeIds = new Set(filteredNodes.map(node => node.id));
      
      // リンクをフィルタリング
      const filteredLinks = linkData.filter(link => 
        nodeIds.has(typeof link.source === 'object' ? link.source.id : link.source) && 
        nodeIds.has(typeof link.target === 'object' ? link.target.id : link.target)
      );
      
      // SVGの寸法設定
      const svgContainer = document.querySelector('.graph-container');
      const width = svgContainer.clientWidth;
      const height = svgContainer.clientHeight;
      
      // ズーム機能を追加
      const g = svg.append('g');
      
      const zoom = d3.zoom()
        .scaleExtent([0.1, 8])
        .on('zoom', (event) => {
          g.attr('transform', event.transform);
        });
      
      svg.call(zoom);
      
      // 初期ズームを設定（全体を表示）
      svg.call(zoom.transform, d3.zoomIdentity.translate(width / 2, height / 2).scale(0.8));
      
      // コミュニティに基づいて色を割り当て
      const color = d3.scaleOrdinal(d3.schemeCategory10);
      
      // シミュレーションの設定
      if (simulation) simulation.stop();
      
      simulation = d3.forceSimulation(filteredNodes)
        .force('link', d3.forceLink(filteredLinks).id(d => d.id).distance(100))
        .force('charge', d3.forceManyBody().strength(-300))
        .force('center', d3.forceCenter(0, 0))
        .force('collision', d3.forceCollide().radius(d => Math.sqrt(d.papers_count) * 4 + 15));
      
      // リンク（エッジ）を描画
      const link = g.append('g')
        .attr('stroke', '#999')
        .attr('stroke-opacity', 0.6)
        .selectAll('line')
        .data(filteredLinks)
        .join('line')
        .attr('stroke-width', d => Math.sqrt(d.value || 1));
      
      // ノードを描画
      const node = g.append('g')
        .selectAll('g')
        .data(filteredNodes)
        .join('g')
        .call(drag(simulation));
      
      // 選択された中心性指標に基づいてノードのサイズを設定
      const getSizeScale = (measure) => {
        const values = filteredNodes.map(d => d[measure]);
        const minVal = d3.min(values) || 0;
        const maxVal = d3.max(values) || 1;
        return d3.scaleLinear()
          .domain([minVal, maxVal])
          .range([5, 25]);
      };
      
      const sizeScale = getSizeScale(settings.centralityMeasure);
      
      // ノードの円を追加
      node.append('circle')
        .attr('r', d => {
          // 論文数によるサイズか選択された中心性指標によるサイズ
          return settings.centralityMeasure === 'papers_count' 
            ? Math.sqrt(d.papers_count) * 4 + 5 
            : sizeScale(d[settings.centralityMeasure]);
        })
        .attr('fill', d => color(d.community))
        .attr('stroke', '#fff')
        .attr('stroke-width', 1.5)
        .append('title')
        .text(d => {
          return `${d.name}
論文数: ${d.papers_count}
共著者数: ${d.coauthors_count}
PageRank: ${d.pagerank.toFixed(6)}
次数中心性: ${d.degree_centrality.toFixed(6)}
媒介中心性: ${d.betweenness_centrality.toFixed(6)}
近接中心性: ${d.closeness_centrality.toFixed(6)}
コミュニティ: ${d.community}`;
        });
      
      // ノードのラベルを追加
      node.append('text')
        .attr('dx', 12)
        .attr('dy', '.35em')
        .text(d => d.name)
        .style('font-size', '12px')
        .style('font-family', 'sans-serif');
      
      // シミュレーションの更新と位置の調整
      simulation.on('tick', () => {
        link
          .attr('x1', d => d.source.x)
          .attr('y1', d => d.source.y)
          .attr('x2', d => d.target.x)
          .attr('y2', d => d.target.y);
        
        node.attr('transform', d => `translate(${d.x},${d.y})`);
      });
      
      // SVGを表示
      svg.style('display', 'block');
    }
    
    // ドラッグ機能
    function drag(simulation) {
      function dragstarted(event) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        event.subject.fx = event.subject.x;
        event.subject.fy = event.subject.y;
      }
      
      function dragged(event) {
        event.subject.fx = event.x;
        event.subject.fy = event.y;
      }
      
      function dragended(event) {
        if (!event.active) simulation.alphaTarget(0);
        event.subject.fx = null;
        event.subject.fy = null;
      }
      
      return d3.drag()
        .on('start', dragstarted)
        .on('drag', dragged)
        .on('end', dragended);
    }
    
    // ヘルパー関数
    function showLoading(isLoading) {
      loadingElement.style.display = isLoading ? 'flex' : 'none';
    }
    
    function showError(message) {
      if (message) {
        errorElement.textContent = message;
        errorElement.style.display = 'block';
      } else {
        errorElement.style.display = 'none';
      }
    }
    
    // ウィンドウサイズ変更時にグラフを再描画
    window.addEventListener('resize', () => {
      createNetworkGraph();
    });
    
    // イベントリスナーの設定
    minPaperCountInput.addEventListener('change', () => {
      settings.minPaperCount = parseInt(minPaperCountInput.value) || 1;
      createNetworkGraph();
    });
    
    maxNodesInput.addEventListener('change', () => {
      settings.maxNodesToShow = parseInt(maxNodesInput.value) || 100;
      createNetworkGraph();
    });
    
    centralityMeasureSelect.addEventListener('change', () => {
      settings.centralityMeasure = centralityMeasureSelect.value;
      createNetworkGraph();
    });
    
    // 初期化
    fetchData();
  </script>
</body>
</html>